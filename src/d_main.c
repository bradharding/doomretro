/*
========================================================================

                           D O O M  R e t r o
         The classic, refined DOOM source port. For Windows PC.

========================================================================

  Copyright © 1993-2012 id Software LLC, a ZeniMax Media company.
  Copyright © 2013-2016 Brad Harding.

  DOOM Retro is a fork of Chocolate DOOM.
  For a list of credits, see the accompanying AUTHORS file.

  This file is part of DOOM Retro.

  DOOM Retro is free software: you can redistribute it and/or modify it
  under the terms of the GNU General Public License as published by the
  Free Software Foundation, either version 3 of the License, or (at your
  option) any later version.

  DOOM Retro is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with DOOM Retro. If not, see <http://www.gnu.org/licenses/>.

  DOOM is a registered trademark of id Software LLC, a ZeniMax Media
  company, in the US and/or other countries and is used without
  permission. All other trademarks are the property of their respective
  holders. DOOM Retro is in no way affiliated with nor endorsed by
  id Software.

========================================================================
*/

#if defined(WIN32)
#pragma comment(lib, "winmm.lib")

#include <windows.h>
#include <Commdlg.h>
#include <MMSystem.h>
#include <ShellAPI.h>
#endif

#if !defined(MAX_PATH)
#define MAX_PATH        260
#endif

#include "am_map.h"
#include "c_console.h"
#include "d_deh.h"
#include "d_iwad.h"
#include "d_main.h"
#include "doomstat.h"
#include "f_finale.h"
#include "f_wipe.h"
#include "g_game.h"
#include "hu_stuff.h"
#include "i_gamepad.h"
#include "i_swap.h"
#include "i_system.h"
#include "i_timer.h"
#include "i_video.h"
#include "m_argv.h"
#include "m_config.h"
#include "m_menu.h"
#include "m_misc.h"
#include "p_local.h"
#include "p_saveg.h"
#include "p_setup.h"
#include "s_sound.h"
#include "SDL.h"
#include "st_stuff.h"
#include "v_video.h"
#include "version.h"
#include "w_merge.h"
#include "w_wad.h"
#include "wi_stuff.h"
#include "z_zone.h"

//
// D-DoomLoop()
// Not a globally visible function,
//  just included for source reference,
//  called by D_DoomMain, never exits.
// Manages timing and IO,
//  calls all ?_Responder, ?_Ticker, and ?_Drawer,
//  calls I_GetTime, I_StartFrame, and I_StartTic
//
void D_DoomLoop(void);

// Location where savegames are stored
char                    *savegamefolder;

// location of IWAD and WAD files
char                    *iwadfile = "";
char                    *pwadfile = "";

char                    *iwadfolder = iwadfolder_default;

char                    *packageconfig;

dboolean                devparm;        // started game with -devparm
dboolean                nomonsters;     // checkparm of -nomonsters
dboolean                pistolstart;    // [BH] checkparm of -pistolstart
dboolean                fastparm;       // checkparm of -fast

unsigned int            stat_runs = 0;

skill_t                 startskill;
int                     startepisode;
int                     startmap;
dboolean                autostart;
int                     startloadgame;

dboolean                advancetitle;
dboolean                wipe = true;
dboolean                forcewipe = false;

dboolean                splashscreen;

extern int              expansion;
extern dboolean         alwaysrun;

int                     startuptimer;

dboolean                realframe;

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
#define MAXEVENTS       64

static event_t          events[MAXEVENTS];
static int              eventhead;
static int              eventtail;

//
// D_PostEvent
// Called by the I/O functions when input is detected
//
void D_PostEvent(event_t *ev)
{
    events[eventhead++] = *ev;
    eventhead &= MAXEVENTS - 1;
}

//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
void D_ProcessEvents(void)
{
    for (; eventtail != eventhead; eventtail = (eventtail + 1) & (MAXEVENTS - 1))
    {
        event_t *ev = events + eventtail;

        if (wipe && ev->type == ev_mouse)
            continue;
        if (C_Responder(ev))
            continue;           // console ate the event
        if (M_Responder(ev))
            continue;           // menu ate the event
        G_Responder(ev);
    }
}

//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
gamestate_t     wipegamestate = GS_TITLESCREEN;

extern dboolean         setsizeneeded;
extern dboolean         message_on;
extern int              r_detail;
extern int              viewheight2;
extern dboolean         loadedgame;

void R_ExecuteSetViewSize(void);
void G_LoadedGameMessage(void);

void D_Display(void)
{
    static dboolean     viewactivestate;
    static dboolean     menuactivestate;
    static dboolean     pausedstate = false;
    static gamestate_t  oldgamestate = (gamestate_t)(-1);
    static int          borderdrawcount;
    static int          saved_gametic = -1;
    int                 nowtime;
    int                 tics;
    int                 wipestart;
    dboolean            done;

    realframe = (vid_capfps || gametic > saved_gametic);
    if (realframe)
        saved_gametic = gametic;

    // change the view size if needed
    if (setsizeneeded)
    {
        R_ExecuteSetViewSize();
        oldgamestate = (gamestate_t)(-1);         // force background redraw
        borderdrawcount = 3;
    }

    // save the current screen if about to wipe
    if ((wipe = (gamestate != wipegamestate || forcewipe)))
    {
        drawdisk = false;
        wipe_StartScreen();
        if (forcewipe)
            forcewipe = false;
        else
            menuactive = false;
    }

    if (gamestate != GS_LEVEL)
    {
        if (gamestate != oldgamestate && !splashscreen)
            I_SetPalette(W_CacheLumpName("PLAYPAL", PU_CACHE));

        switch (gamestate)
        {
            case GS_INTERMISSION:
                WI_Drawer();
                break;

            case GS_FINALE:
                F_Drawer();
                break;

            case GS_TITLESCREEN:
                D_PageDrawer();
                break;
        }
    }
    else
    {
        HU_Erase();

        ST_Drawer(viewheight == SCREENHEIGHT, true);

        // draw the view directly
        R_RenderPlayerView(&players[0]);

        if ((mapwindow && realframe) || automapactive)
            AM_Drawer();

        // see if the border needs to be initially drawn
        if (oldgamestate != GS_LEVEL)
        {
            viewactivestate = false;    // view was not active
            R_FillBackScreen();         // draw the pattern into the back screen
        }

        // see if the border needs to be updated to the screen
        if (!automapactive)
        {
            if (scaledviewwidth != SCREENWIDTH)
            {
                if (menuactive || menuactivestate || !viewactivestate || vid_showfps
                    || paused || pausedstate || message_on || consoleheight > CONSOLETOP)
                    borderdrawcount = 3;
                if (borderdrawcount)
                {
                    R_DrawViewBorder();     // erase old menu stuff
                    --borderdrawcount;
                }
            }
            if (r_detail == r_detail_low)
                V_LowGraphicDetail(viewheight2 * SCREENWIDTH);
        }

        HU_Drawer();
    }

    menuactivestate = menuactive;
    viewactivestate = viewactive;
    oldgamestate = wipegamestate = gamestate;

    // draw pause pic
    if ((pausedstate = paused))
    {
        M_DarkBackground();
        if (M_PAUSE)
        {
            patch_t     *patch = W_CacheLumpName("M_PAUSE", PU_CACHE);

            if (vid_widescreen)
                V_DrawPatchWithShadow((ORIGINALWIDTH - SHORT(patch->width)) / 2,
                    viewwindowy / 2 + (viewheight / 2 - SHORT(patch->height)) / 2, patch, false);
            else
                V_DrawPatchWithShadow((ORIGINALWIDTH - SHORT(patch->width)) / 2,
                    (ORIGINALHEIGHT - SHORT(patch->height)) / 2, patch, false);
        }
        else
        {
            if (vid_widescreen)
                M_DrawCenteredString(viewwindowy / 2 + (viewheight / 2 - 16) / 2, s_M_PAUSED);
            else
                M_DrawCenteredString((ORIGINALHEIGHT - 16) / 2, s_M_PAUSED);
        }
    }

    if (!wipe)
    {
        C_Drawer();

        // menus go directly to the screen
        M_Drawer();             // menu is drawn even on top of everything

        // normal update
        blitfunc();             // page flip or blit buffer

        mapblitfunc();

        return;
    }

    // wipe update
    wipe_EndScreen();

    wipestart = I_GetTime() - 1;

    do
    {
        do
        {
            nowtime = I_GetTime();
            tics = nowtime - wipestart;
            I_Sleep(1);
        }
        while (tics <= 0);

        wipestart = nowtime;
        done = wipe_ScreenWipe(tics);
        blurred = false;

        C_Drawer();

        M_Drawer();             // menu is drawn even on top of wipes
        blitfunc();             // page flip or blit buffer

        mapblitfunc();
    }
    while (!done);

    if (loadedgame)
        G_LoadedGameMessage();
}

//
//  D_DoomLoop
//
void D_DoomLoop(void)
{
    TryRunTics();

    R_ExecuteSetViewSize();

    D_StartGameLoop();

    while (1)
    {
        TryRunTics(); // will run at least one tic

        if (players[0].mo)
            S_UpdateSounds(players[0].mo);  // move positional sounds

        // Update display, next frame, with current state.
        D_Display();
    }
}

//
//  TITLE LOOP
//
int             titlesequence;
int             pagetic;
static int      pagewait;
static patch_t  *pagelump;
static patch_t  *splashlump;
static patch_t  *titlelump;
static patch_t  *creditlump;
static byte     *splashpal;
static byte     *playpal;

//
// D_PageTicker
// Handles timing for warped projection
//
void D_PageTicker(void)
{
    if (!menuactive && !startingnewgame && !consoleheight)
    {
        if (pagewait < I_GetTime())
        {
            --pagetic;
            pagewait = I_GetTime();
        }

        if (pagetic < 0)
            D_AdvanceTitle();
    }
}

//
// D_PageDrawer
//
void D_PageDrawer(void)
{
    if (splashscreen)
    {
        I_SetPalette(splashpal + (pagetic >= 95 ? pagetic - 95 :
            (pagetic < 10 ? 10 - pagetic - 1 : 0)) * 768);

        V_DrawBigPatch(0, 0, 0, splashlump);
    }
    else if (pagelump)
        V_DrawPagePatch(pagelump);
}

//
// D_AdvanceTitle
// Called after each titlesequence finishes
//
void D_AdvanceTitle(void)
{
    advancetitle = true;
}

//
// This cycles through the title sequence.
//
void D_DoAdvanceTitle(void)
{
    static dboolean     flag = true;

    players[0].playerstate = PST_LIVE;  // not reborn
    advancetitle = false;
    usergame = false;                   // no save / end game here
    paused = false;
    gameaction = ga_nothing;
    gamestate = GS_TITLESCREEN;
    blurred = false;
    noinput = false;

    switch (titlesequence)
    {
        case 0:
            pagetic = 3 * TICRATE;
            splashscreen = true;
            break;

        case 1:
            if (flag)
            {
                flag = false;
                I_InitKeyboard();
                if (alwaysrun)
                    C_StrCVAROutput(stringize(alwaysrun), "on");
            }

            if (pagelump == creditlump)
                forcewipe = true;
            pagelump = titlelump;
            pagetic = 20 * TICRATE;
            if (splashscreen)
            {
                I_SetPalette(playpal);
                splashscreen = false;
                if (!TITLEPIC)
                    M_StartControlPanel();
            }
            M_SetWindowCaption();
            S_StartMusic(gamemode == commercial ? mus_dm2ttl : mus_intro);
            break;

        case 2:
            forcewipe = true;
            pagelump = creditlump;
            pagetic = 10 * TICRATE;
            break;
    }

    if (++titlesequence > 2)
        titlesequence = 1;
}

//
// D_StartTitle
//
void D_StartTitle(int page)
{
    gameaction = ga_nothing;
    titlesequence = page;

    if (mapwindow)
        AM_clearFB();

    D_AdvanceTitle();
}

// Initialize the game version
static void InitGameVersion(void)
{
    // Determine automatically
    if (gamemode == shareware || gamemode == registered)
        // original
        gameversion = exe_doom_1_9;
    else if (gamemode == retail)
        gameversion = exe_ultimate;
    else if (gamemode == commercial)
    {
        if (gamemission == doom2)
            gameversion = exe_doom_1_9;
        else
            // Final DOOM: tnt or plutonia
            gameversion = exe_final;
    }

    // The original exe does not support retail - 4th episode not supported
    if (gameversion < exe_ultimate && gamemode == retail)
        gamemode = registered;

    // EXEs prior to the Final DOOM exes do not support Final DOOM.
    if (gameversion < exe_final && gamemode == commercial)
        gamemission = doom2;
}

void ProcessDehFile(char *filename, int lump);

#define MAXDEHFILES 16

static char     dehfiles[MAXDEHFILES][MAX_PATH];
static int      dehfilecount;

dboolean DehFileProcessed(char *path)
{
    int i;

    for (i = 0; i < dehfilecount; ++i)
        if (M_StringCompare(path, dehfiles[i]))
            return true;
    return false;
}

static void LoadDehFile(char *path)
{
    if (!M_ParmExists("-nodeh") && !HasDehackedLump(path))
    {
        char            *dehpath = M_StringReplace(path, ".wad", ".bex");

        if (M_FileExists(dehpath) && !DehFileProcessed(dehpath))
        {
            if (chex)
                chexdeh = true;
            ProcessDehFile(dehpath, 0);
            if (dehfilecount < MAXDEHFILES)
                M_StringCopy(dehfiles[dehfilecount++], dehpath, MAX_PATH);
        }
        else
        {
            char        *dehpath = M_StringReplace(path, ".wad", ".deh");

            if (M_FileExists(dehpath) && !DehFileProcessed(dehpath))
            {
                ProcessDehFile(dehpath, 0);
                if (dehfilecount < MAXDEHFILES)
                    M_StringCopy(dehfiles[dehfilecount++], dehpath, MAX_PATH);
            }
        }
    }
}

static void LoadCfgFile(char *path)
{
    char        *cfgpath = M_StringReplace(path, ".wad", ".cfg");

    if (M_FileExists(cfgpath))
        M_LoadCVARs(cfgpath);
}

static dboolean D_IsDOOMIWAD(char *filename)
{
    return (M_StringCompare(leafname(filename), "DOOM.WAD")
        || M_StringCompare(leafname(filename), "DOOM1.WAD")
        || M_StringCompare(leafname(filename), "DOOM2.WAD")
        || M_StringCompare(leafname(filename), "PLUTONIA.WAD")
        || M_StringCompare(leafname(filename), "TNT.WAD")
        || (hacx = M_StringCompare(leafname(filename), "HACX.WAD")));
}

static dboolean D_IsUnsupportedIWAD(char *filename)
{
    return (M_StringCompare(leafname(filename), "HERETIC1.WAD")
        || M_StringCompare(leafname(filename), "HERETIC.WAD")
        || M_StringCompare(leafname(filename), "HEXEN.WAD")
        || M_StringCompare(leafname(filename), "HEXDD.WAD")
        || M_StringCompare(leafname(filename), "STRIFE0.WAD")
        || M_StringCompare(leafname(filename), "STRIFE1.WAD"));
}

static dboolean D_IsCfgFile(char *filename)
{
    return (M_StringCompare(filename + strlen(filename) - 4, ".cfg"));
}

static dboolean D_IsDehFile(char *filename)
{
    return (M_StringCompare(filename + strlen(filename) - 4, ".deh")
        || M_StringCompare(filename + strlen(filename) - 4, ".bex"));
}

static void D_CheckSupportedPWAD(char *filename)
{
    if (M_StringCompare(leafname(filename), "NERVE.WAD"))
    {
        nerve = true;
        expansion = 1;
    }
    else if (M_StringCompare(leafname(filename), "BREACH.WAD"))
        breach = true;
    else if (M_StringCompare(leafname(filename), "CHEX.WAD"))
        chex = true;
    else if (M_StringCompare(leafname(filename), "BTSX_E1.WAD"))
        BTSX = BTSXE1 = true;
    else if (M_StringCompare(leafname(filename), "BTSX_E2A.WAD"))
        BTSX = BTSXE2 = BTSXE2A = true;
    else if (M_StringCompare(leafname(filename), "BTSX_E2B.WAD"))
        BTSX = BTSXE2 = BTSXE2B = true;
    else if (M_StringCompare(leafname(filename), "BTSX_E3A.WAD"))
        BTSX = BTSXE3 = BTSXE3A = true;
    else if (M_StringCompare(leafname(filename), "BTSX_E3B.WAD"))
        BTSX = BTSXE3 = BTSXE3B = true;
    else if (M_StringCompare(leafname(filename), "E1M8B.WAD"))
        E1M8B = true;
}

static dboolean D_IsUnsupportedPWAD(char *filename)
{
    return (M_StringCompare(leafname(filename), "VOICES.WAD"));
}

#if defined(__MACOSX__)
#import <Cocoa/Cocoa.h>

#define CTRL    "CMD"
#else
#define CTRL    "CTRL"
#endif

static void D_FirstUse(void)
{
    char *msg = "Thank you for downloading "PACKAGE_NAME"!\n\nPlease note that, as with all "
        "DOOM source ports, the actual content required to play\nDOOM isn\xe2\x80\x99t included "
        "with "PACKAGE_NAME".\n\nIn the WAD launcher that follows, please navigate to where one "
        "of the official \xe2\x80\x9cIWADs\xe2\x80\x9d\n(such as DOOM.WAD or DOOM2.WAD) has "
        "previously been installed.\n\nOnce "PACKAGE_NAME" knows where these IWAD(s) are, "
        "additional \xe2\x80\x9cPWADs\xe2\x80\x9d may then be\nselected by clicking or "CTRL
        "-clicking on them.\n\nVisit the "PACKAGE_NAME" Wiki for more information.";

    const SDL_MessageBoxButtonData buttons[] =
    {
#if defined(WIN32)
        {                                       0, 0, "&Wiki"   },
#endif
        { SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT, 1, "&Cancel" },
        { SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT, 2, "&Next >" }
    };

    const SDL_MessageBoxData messageboxdata =
    {
        SDL_MESSAGEBOX_INFORMATION,
        NULL,
        PACKAGE_NAME,
        msg,
        SDL_arraysize(buttons),
        buttons,
        NULL
    };

    int buttonid;

    if (SDL_ShowMessageBox(&messageboxdata, &buttonid) >= 0)
    {
#if defined(WIN32)
        if (buttons[buttonid].buttonid == 0)
        {
            ShellExecute(GetActiveWindow(), "open", PACKAGE_WIKI_URL, NULL, NULL, SW_SHOWNORMAL);
            I_Quit(false);
        }
        else
#endif
        if (buttons[buttonid].buttonid == 1)
            I_Quit(false);
    }
}

#if defined(WIN32) || defined(__MACOSX__)
static int D_ChooseIWAD(void)
{
    int                 iwadfound = -1;
    dboolean            fileopenedok = false;

#if defined(WIN32)
    OPENFILENAME        ofn;
    char                szFile[4096];

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = NULL;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = '\0';
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFilter = "IWAD/PWAD Files (*.wad)\0*.WAD;*.DEH;*.BEX;*.CFG\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = iwadfolder;
    ofn.Flags = (OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_ALLOWMULTISELECT | OFN_PATHMUSTEXIST
        | OFN_FILEMUSTEXIST | OFN_EXPLORER);
    ofn.lpstrTitle = "Where\u2019s All the Data?\0";

    fileopenedok = GetOpenFileName(&ofn);

#elif defined(__MACOSX__)
    NSOpenPanel *panel = [NSOpenPanel openPanel];

    [panel setCanChooseFiles:YES];
    [panel setCanChooseDirectories:NO];
    [panel setAllowsMultipleSelection:YES];
    [panel setTitle:@"Where's All the Data?"];

    NSInteger   clicked = [panel runModal];

    fileopenedok = clicked == NSFileHandlingPanelOKButton;
#endif

    if (fileopenedok)
    {
        dboolean        onlyoneselected;

        iwadfound = 0;
        startuptimer = I_GetTimeMS();

        // only one file was selected
#if defined(WIN32)
        onlyoneselected = !ofn.lpstrFile[lstrlen(ofn.lpstrFile) + 1];
#elif defined __MACOSX__
        NSArray *urls = [panel URLs];

        onlyoneselected = [urls count] == 1;
#endif
        if (onlyoneselected)
        {
#if defined(WIN32)
            char        *file = (char *)ofn.lpstrFile;
#elif defined(__MACOSX__)
            NSURL       *url = [urls objectAtIndex:0];
            char        *file = (char *)[url fileSystemRepresentation];
#endif

            // check if it's a valid and supported IWAD
            if (D_IsDOOMIWAD(file) || (W_WadType(file) == IWAD && !D_IsUnsupportedIWAD(file)))
            {
                IdentifyIWADByName(file);
                if (W_AddFile(file, false))
                {
                    iwadfound = 1;
                    iwadfolder = strdup(M_ExtractFolder(file));

                    // if DOOM2.WAD is selected, load NERVE.WAD automatically if present
                    if (M_StringCompare(leafname(file), "DOOM2.WAD"))
                    {
                        static char     fullpath[MAX_PATH];

                        M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s",
                            M_ExtractFolder(file), "NERVE.WAD");
                        if (W_MergeFile(fullpath, true))
                        {
                            modifiedgame = true;
                            nerve = true;
                            expansion = 0;
                        }
                    }
                }
            }

            // if it's a PWAD, determine the IWAD required and try loading that as well
            else if (W_WadType(file) == PWAD && !D_IsUnsupportedPWAD(file))
            {
                int             iwadrequired = IWADRequiredByPWAD(file);
                static char     fullpath[MAX_PATH];

                if (iwadrequired == indetermined)
                    iwadrequired = doom2;

                // try the current folder first
                M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s",
                    M_ExtractFolder(file), (iwadrequired == doom ? "DOOM.WAD" : "DOOM2.WAD"));
                IdentifyIWADByName(fullpath);
                if (W_AddFile(fullpath, true))
                {
                    iwadfound = 1;
                    iwadfolder = strdup(M_ExtractFolder(fullpath));
                    D_CheckSupportedPWAD(file);
                    if (W_MergeFile(file, false))
                    {
                        modifiedgame = true;
                        pwadfile = lowercase(removeext(leafname(file)));
                        LoadCfgFile(file);
                        LoadDehFile(file);
                    }
                }
                else
                {
                    // otherwise try the iwadfolder setting in doomretro.cfg
                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s", iwadfolder,
                        (iwadrequired == doom ? "DOOM.WAD" : "DOOM2.WAD"));
                    IdentifyIWADByName(fullpath);
                    if (W_AddFile(fullpath, true))
                    {
                        iwadfound = 1;
                        D_CheckSupportedPWAD(file);
                        if (W_MergeFile(file, false))
                        {
                            modifiedgame = true;
                            pwadfile = lowercase(removeext(leafname(file)));
                            LoadCfgFile(file);
                            LoadDehFile(file);
                        }
                    }
                    else
                    {
                        // still nothing? try the DOOMWADDIR environment variable
                        M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s",
                            getenv("DOOMWADDIR"), (iwadrequired == doom ? "DOOM.WAD" :
                            "DOOM2.WAD"));
                        IdentifyIWADByName(fullpath);
                        if (W_AddFile(fullpath, true))
                        {
                            iwadfound = 1;
                            D_CheckSupportedPWAD(file);
                            if (W_MergeFile(file, false))
                            {
                                modifiedgame = true;
                                pwadfile = lowercase(removeext(leafname(file)));
                                LoadCfgFile(file);
                                LoadDehFile(file);
                            }
                        }
                    }
                }
            }

            if (BTSX)
            {
                static char     fullpath[MAX_PATH];

                if (BTSXE2A && !BTSXE2B)
                {
                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s",
                        M_ExtractFolder(file), "BTSX_E2B.WAD");
                    return W_MergeFile(fullpath, true);
                }
                else if (!BTSXE2A && BTSXE2B)
                {
                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s",
                        M_ExtractFolder(file), "BTSX_E2A.WAD");
                    return W_MergeFile(fullpath, true);
                }
                else if (BTSXE3A && !BTSXE3B)
                {
                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s",
                        M_ExtractFolder(file), "BTSX_E3B.WAD");
                    return W_MergeFile(fullpath, true);
                }
                else if (!BTSXE3A && BTSXE3B)
                {
                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s",
                        M_ExtractFolder(file), "BTSX_E3A.WAD");
                    return W_MergeFile(fullpath, true);
                }
            }
        }

        // more than one file was selected
        else
        {
            dboolean    isDOOM2 = false;
            dboolean    sharewareiwad = false;

#if defined(WIN32)
            LPSTR       iwadpass = ofn.lpstrFile;
            LPSTR       pwadpass1 = ofn.lpstrFile;
            LPSTR       pwadpass2 = ofn.lpstrFile;
            LPSTR       cfgpass = ofn.lpstrFile;
            LPSTR       dehpass = ofn.lpstrFile;

            iwadpass += lstrlen(iwadpass) + 1;

            // find and add IWAD first
            while (iwadpass[0])
            {
                static char     fullpath[MAX_PATH];

                M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s", szFile, iwadpass);

#elif defined(__MACOSX__)
            char        *szFile;

            for (NSURL* url in urls)
            {
                char    *fullpath = (char *)[url fileSystemRepresentation];
                char    *iwadpass = (char *)[[url lastPathComponent] UTF8String];

                szFile = (char *)[[url URLByDeletingLastPathComponent] fileSystemRepresentation];
#endif

                if (D_IsDOOMIWAD(fullpath) || (W_WadType(fullpath) == IWAD
                    && !D_IsUnsupportedIWAD(fullpath)))
                {
                    if (!iwadfound)
                    {
                        IdentifyIWADByName(fullpath);
                        if (W_AddFile(fullpath, false))
                        {
                            iwadfound = 1;
                            sharewareiwad = M_StringCompare(iwadpass, "DOOM1.WAD");
                            isDOOM2 = M_StringCompare(iwadpass, "DOOM2.WAD");
                            iwadfolder = strdup(M_ExtractFolder(fullpath));
                            break;
                        }
                    }
                }

                // if it's NERVE.WAD, try to open DOOM2.WAD with it
                else if (M_StringCompare(iwadpass, "NERVE.WAD"))
                {
                    static char     fullpath2[MAX_PATH];

                    // try the current folder first
                    M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S"DOOM2.WAD",
                        szFile);
                    IdentifyIWADByName(fullpath2);
                    if (W_AddFile(fullpath2, true))
                    {
                        iwadfound = 1;
                        if (W_MergeFile(fullpath, false))
                        {
                            modifiedgame = true;
                            nerve = true;
                            expansion = 1;
                        }
                        break;
                    }
                    else
                    {
                        // otherwise try the iwadfolder setting in doomretro.cfg
                        M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S"DOOM2.WAD",
                            iwadfolder);
                        IdentifyIWADByName(fullpath2);
                        if (W_AddFile(fullpath2, true))
                        {
                            iwadfound = 1;
                            if (W_MergeFile(fullpath, false))
                            {
                                modifiedgame = true;
                                nerve = true;
                                expansion = 1;
                            }
                            break;
                        }
                        else
                        {
                            // still nothing? try the DOOMWADDIR environment variable
                            M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S
                                "DOOM2.WAD", getenv("DOOMWADDIR"));
                            IdentifyIWADByName(fullpath2);
                            if (W_AddFile(fullpath2, true))
                            {
                                iwadfound = 1;
                                if (W_MergeFile(fullpath, false))
                                {
                                    modifiedgame = true;
                                    nerve = true;
                                    expansion = 1;
                                }
                                break;
                            }
                        }
                    }
                }
#if defined(WIN32)
                iwadpass += lstrlen(iwadpass) + 1;
#endif
            }

            // merge any pwads
            if (!sharewareiwad)
            {
                // if no iwad has been selected, check each pwad to determine the iwad required
                // and then try to load it first
#if defined(WIN32)
                pwadpass1 += lstrlen(pwadpass1) + 1;

                while (!iwadfound && pwadpass1[0])
                {
                    static char     fullpath[MAX_PATH];

                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s", szFile,
                        pwadpass1);
#elif defined(__MACOSX__)
                for (NSURL* url in urls)
                {
                    char    *fullpath = (char *)[url fileSystemRepresentation];
                    char    *pwadpass1 = (char *)[[url lastPathComponent] UTF8String];
#endif

                    if (W_WadType(fullpath) == PWAD && !D_IsUnsupportedPWAD(fullpath)
                        && !D_IsDehFile(fullpath))
                    {
                        int     iwadrequired = IWADRequiredByPWAD(fullpath);

                        if (iwadrequired != indetermined)
                        {
                            static char fullpath2[MAX_PATH];

                            // try the current folder first
                            M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S"%s",
                                szFile, (iwadrequired == doom ? "DOOM.WAD" : "DOOM2.WAD"));
                            IdentifyIWADByName(fullpath2);
                            if (W_AddFile(fullpath2, true))
                            {
                                iwadfound = 1;
                                iwadfolder = strdup(M_ExtractFolder(fullpath2));
                            }
                            else
                            {
                                // otherwise try the iwadfolder setting in doomretro.cfg
                                M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S"%s",
                                    iwadfolder, (iwadrequired == doom ? "DOOM.WAD" : "DOOM2.WAD"));
                                IdentifyIWADByName(fullpath2);
                                if (W_AddFile(fullpath2, true))
                                    iwadfound = 1;
                                else
                                {
                                    // still nothing? try the DOOMWADDIR environment variable
                                    M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S
                                        "%s", getenv("DOOMWADDIR"), (iwadrequired == doom ?
                                        "DOOM.WAD" : "DOOM2.WAD"));
                                    IdentifyIWADByName(fullpath2);
                                    if (W_AddFile(fullpath2, true))
                                        iwadfound = 1;
                                }
                            }
                        }
                    }
#if defined(WIN32)
                    pwadpass1 += lstrlen(pwadpass1) + 1;
#endif
                }

                // if still no iwad found, then try DOOM2.WAD
                if (!iwadfound)
                {
                    // try the current folder first
                    IdentifyIWADByName("DOOM2.WAD");
                    if (W_AddFile("DOOM2.WAD", true))
                        iwadfound = 1;
                    else
                    {
                        static char fullpath2[MAX_PATH];

                        // otherwise try the iwadfolder setting in doomretro.cfg
                        M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S"DOOM2.WAD",
                            iwadfolder);
                        IdentifyIWADByName(fullpath2);
                        if (W_AddFile(fullpath2, true))
                            iwadfound = 1;
                        else
                        {
                            // still nothing? try the DOOMWADDIR environment variable
                            M_snprintf(fullpath2, sizeof(fullpath2), "%s"DIR_SEPARATOR_S
                                "DOOM2.WAD", getenv("DOOMWADDIR"));
                            IdentifyIWADByName(fullpath2);
                            if (W_AddFile(fullpath2, true))
                                iwadfound = 1;
                        }
                    }
                }

                // if an iwad has now been found, make second pass through the pwads to merge them
                if (iwadfound)
                {
                    dboolean    mapspresent = false;
#if defined(WIN32)
                    pwadpass2 += lstrlen(pwadpass2) + 1;

                    while (pwadpass2[0])
                    {
                        static char     fullpath[MAX_PATH];

                        M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s", szFile,
                            pwadpass2);
#elif defined(__MACOSX__)
                    for (NSURL *url in urls)
                    {
                        char    *fullpath = (char *)[url fileSystemRepresentation];
#endif
                        if (W_WadType(fullpath) == PWAD && !D_IsUnsupportedPWAD(fullpath)
                            && !D_IsDehFile(fullpath))
                        {
                            D_CheckSupportedPWAD(fullpath);
                            if (W_MergeFile(fullpath, false))
                            {
                                modifiedgame = true;
                                LoadCfgFile(fullpath);
                                LoadDehFile(fullpath);
                                if (IWADRequiredByPWAD(fullpath) != indetermined)
                                {
                                    mapspresent = true;
                                    pwadfile = lowercase(removeext(leafname(fullpath)));
                                }
                            }
                        }
#if defined(WIN32)
                        pwadpass2 += lstrlen(pwadpass2) + 1;
#endif
                    }

                    // try to autoload NERVE.WAD if DOOM2.WAD is the iwad and none of the pwads
                    // have maps present
                    if (isDOOM2 && !mapspresent)
                    {
                        static char     fullpath[MAX_PATH];

                        M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s", szFile,
                            "NERVE.WAD");
                        if (W_MergeFile(fullpath, true))
                        {
                            modifiedgame = true;
                            nerve = true;
                            expansion = 0;
                        }
                    }
                }
            }

            if (iwadfound)
            {
#if defined(WIN32)
                // process any config files
                cfgpass += lstrlen(cfgpass) + 1;

                while (cfgpass[0])
                {
                    static char     fullpath[MAX_PATH];

                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s", szFile,
                        cfgpass);

#elif defined(__MACOSX__)
                for (NSURL *url in urls)
                {
                    char    *fullpath = (char *)[url fileSystemRepresentation];
#endif

                    if (D_IsCfgFile(fullpath))
                        M_LoadCVARs(fullpath);
#if defined(WIN32)
                    cfgpass += lstrlen(cfgpass) + 1;
#endif
            }

#if defined(WIN32)
                // process any dehacked files last of all
                dehpass += lstrlen(dehpass) + 1;

                while (dehpass[0])
                {
                    static char     fullpath[MAX_PATH];

                    M_snprintf(fullpath, sizeof(fullpath), "%s"DIR_SEPARATOR_S"%s", szFile,
                        dehpass);

#elif defined(__MACOSX__)
                for (NSURL *url in urls)
                {
                    char    *fullpath = (char *)[url fileSystemRepresentation];
#endif

                    if (D_IsDehFile(fullpath))
                        LoadDehFile(fullpath);
#if defined(WIN32)
                    dehpass += lstrlen(dehpass) + 1;
#endif
                }
            }
        }
    }
    return iwadfound;
}
#endif

void (*P_BloodSplatSpawner)(fixed_t, fixed_t, int, int, mobj_t *);

dboolean CheckPackageWADVersion(void);

static void D_ProcessDehCommandLine(void)
{
    int p = M_CheckParm("-deh");

    if (p || (p = M_CheckParm("-bex")))
    {
        dboolean        deh = true;

        while (++p < myargc)
            if (*myargv[p] == '-')
                deh = (M_StringCompare(myargv[p], "-deh") || M_StringCompare(myargv[p], "-bex"));
            else if (deh)
                ProcessDehFile(myargv[p], 0);
    }
}

static void D_ProcessDehInWad(void)
{
    int i;

    if (chexdeh || M_ParmExists("-nodeh"))
        return;

    for (i = 0; i < numlumps; ++i)
        if (!strncasecmp(lumpinfo[i]->name, "DEHACKED", 8))
            ProcessDehFile(NULL, i);
}

//
// D_DoomMainSetup
//
// CPhipps - the old contents of D_DoomMain, but moved out of the main
//  line of execution so its stack space can be freed
static void D_DoomMainSetup(void)
{
    int         p;
    int         choseniwad = 0;
    static char lumpname[6];
    char        *resourcefolder = M_GetResourceFolder();
    char        *appdatafolder = M_GetAppDataFolder();
    char        *packagewad = M_StringJoin(resourcefolder, DIR_SEPARATOR_S, PACKAGE_WAD, NULL);
    
    M_MakeDirectory(appdatafolder);

    packageconfig = M_StringJoin(appdatafolder, DIR_SEPARATOR_S, PACKAGE_CONFIG, NULL);

    C_Output("");
    C_PrintCompileDate();

#if defined(WIN32)
    I_PrintWindowsVersion();
#endif

    C_PrintSDLVersions();

    iwadfile = D_FindIWAD();

    modifiedgame = false;

    D_ProcessDehCommandLine();

    if (nomonsters = M_CheckParm("-nomonsters"))
        C_Output("\"-NOMONSTERS\" was found on the command-line. No monsters will be spawned.");

    if (pistolstart = M_CheckParm("-pistolstart"))
        C_Output("\"-PISTOLSTART\" was found on the command-line. The player will start each map "
            "with only a pistol.");

    if (fastparm = M_CheckParm("-fast"))
        C_Output("\"-FAST\" was found on the command-line. Monsters will be faster.");

    devparm = M_CheckParm("-devparm");

    // turbo option
    p = M_CheckParm("-turbo");
    if (p)
    {
        int             scale = 200;
        extern int      forwardmove[2];
        extern int      sidemove[2];

        if (p < myargc - 1)
            scale = BETWEEN(10, atoi(myargv[p + 1]), 400);
        forwardmove[0] *= scale / 100;
        forwardmove[1] *= scale / 100;
        sidemove[0] *= scale / 100;
        sidemove[1] *= scale / 100;
        C_Output("\"-TURBO %s\" was found on the command-line. The player will be %i%% faster.",
            myargv[p + 1], scale);
    }

    // Load configuration files before initializing other subsystems.
    p = M_CheckParmWithArgs("-config", 1, 1);
    M_LoadCVARs(p ? myargv[p + 1] : packageconfig);

    // init subsystems
    V_Init();
    I_InitTimer();

    if (stat_runs < 2)
        C_Output("~"PACKAGE_NAME"~ has been run %s.", (!stat_runs ? "once" : "twice"));
    else
        C_Output("~"PACKAGE_NAME"~ has been run %s times.", commify(SafeAdd(stat_runs, 1)));

    if (!M_FileExists(packagewad))
        I_Error("%s can't be found.\nPlease reinstall "PACKAGE_NAME".", uppercase(packagewad));

    p = M_CheckParmsWithArgs("-file", "-pwad", 1, 1);

    if (iwadfile)
    {
        startuptimer = I_GetTimeMS();
        if (W_AddFile(iwadfile, false))
            stat_runs = SafeAdd(stat_runs, 1);
    }
    else if (!p)
    {
        if (!stat_runs)
            D_FirstUse();

#if defined(WIN32) || defined(__MACOSX__)
        do
        {
            if ((choseniwad = D_ChooseIWAD()) == -1)
                I_Quit(false);
#if defined(WIN32)
            else if (!choseniwad)
                PlaySound((LPCTSTR)SND_ALIAS_SYSTEMHAND, NULL, (SND_ALIAS_ID | SND_ASYNC));
#endif
        } while (!choseniwad);
#endif

        stat_runs = SafeAdd(stat_runs, 1);
    }
    M_SaveCVARs();

    if (p > 0)
        do
            for (p = p + 1; p < myargc && myargv[p][0] != '-'; ++p)
            {
                char        *file = D_TryFindWADByName(myargv[p]);

                if (iwadfile)
                {
                    D_CheckSupportedPWAD(file);
                    if (W_MergeFile(file, false))
                    {
                        modifiedgame = true;
                        if (IWADRequiredByPWAD(file) != indetermined)
                            pwadfile = uppercase(removeext(leafname(file)));
                    }
                }
            }
        while ((p = M_CheckParmsWithArgs("-file", "-pwad", 1, p)));

    if (!iwadfile && !modifiedgame && !choseniwad)
        I_Error("Game mode indeterminate. No IWAD file was found. Try\n"
                "specifying one with the -IWAD command-line parameter.");

    if (!W_MergeFile(packagewad, true))
        I_Error("%s can't be found.\nPlease reinstall "PACKAGE_NAME".", uppercase(packagewad));

    if (!CheckPackageWADVersion())
        I_Error("%s is the wrong version.\nPlease reinstall "PACKAGE_NAME".",
            uppercase(packagewad));

    FREEDOOM = (W_CheckNumForName("FREEDOOM") >= 0);
    FREEDM = (W_CheckNumForName("FREEDM") >= 0);

    DMENUPIC = (W_CheckNumForName("DMENUPIC") >= 0);
    M_DOOM = (W_CheckMultipleLumps("M_DOOM") > 1);
    M_EPISOD = (W_CheckMultipleLumps("M_EPISOD") > 1);
    M_GDHIGH = (W_CheckMultipleLumps("M_GDHIGH") > 1);
    M_GDLOW = (W_CheckMultipleLumps("M_GDLOW") > 1);
    M_LOADG = (W_CheckMultipleLumps("M_LOADG") > 1);
    M_LSCNTR = (W_CheckMultipleLumps("M_LSCNTR") > 1);
    M_MSENS = (W_CheckMultipleLumps("M_MSENS") > 1);
    M_MSGOFF = (W_CheckMultipleLumps("M_MSGOFF") > 1);
    M_MSGON = (W_CheckMultipleLumps("M_MSGON") > 1);
    M_NEWG = (W_CheckMultipleLumps("M_NEWG") > 1);
    M_NMARE = (W_CheckMultipleLumps("M_NMARE") > 1);
    M_OPTTTL = (W_CheckMultipleLumps("M_OPTTTL") > 1);
    M_PAUSE = (W_CheckMultipleLumps("M_PAUSE") > 1);
    M_SAVEG = (W_CheckMultipleLumps("M_SAVEG") > 1);
    M_SKILL = (W_CheckMultipleLumps("M_SKILL") > 1);
    M_SKULL1 = (W_CheckMultipleLumps("M_SKULL1") > 1);
    M_SVOL = (W_CheckMultipleLumps("M_SVOL") > 1);
    STARMS = (W_CheckMultipleLumps("STARMS") > 2);
    STBAR = (W_CheckMultipleLumps("STBAR") > 2);
    STCFN034 = (W_CheckMultipleLumps("STCFN034") > 1);
    STCFN039 = (W_CheckMultipleLumps("STCFN039") > 1);
    STCFN121 = (W_CheckMultipleLumps("STCFN121") > 1);
    STYSNUM0 = (W_CheckMultipleLumps("STYSNUM0") > 1);
    TITLEPIC = (W_CheckNumForName("TITLEPIC") >= 0);
    WISCRT2 = (W_CheckMultipleLumps("WISCRT2") > 1);

    bfgedition = (DMENUPIC && W_CheckNumForName("M_ACPT") >= 0);

    // Generate the WAD hash table. Speed things up a bit.
    W_GenerateHashTable();

    D_IdentifyVersion();
    InitGameVersion();
    D_ProcessDehInWad();
    D_SetGameDescription();
    D_SetSaveGameFolder();

    I_InitGamepad();

    I_InitGraphics();

    // Check for -file in shareware
    if (modifiedgame)
    {
        if (gamemode == shareware)
            I_Error("You cannot use -FILE with the shareware version.\n"
                    "Please purchase the full version.");

        // Check for fake IWAD with right name,
        // but w/o all the lumps of the registered version.
        if (gamemode == registered)
        {
            // These are the lumps that will be checked in IWAD,
            // if any one is not present, execution will be aborted.
            char name[23][9] =
            {
                "E2M1", "E2M2", "E2M3", "E2M4", "E2M5", "E2M6", "E2M7", "E2M8", "E2M9",
                "E3M1", "E3M3", "E3M3", "E3M4", "E3M5", "E3M6", "E3M7", "E3M8", "E3M9",
                "DPHOOF", "BFGGA0", "HEADA1", "CYBRA1", "SPIDA1D1"
            };
            int i;

            for (i = 0; i < 23; ++i)
                if (W_CheckNumForName(name[i]) < 0)
                    I_Error("This is not the registered version.");
        }
    }

    // get skill / episode / map from parms
    startskill = sk_medium;
    startepisode = 1;
    startmap = 1;
    autostart = false;

    p = M_CheckParmWithArgs("-skill", 1, 1);
    if (p)
    {
        int     temp = myargv[p + 1][0] - '1';

        if (temp >= sk_baby && temp <= sk_nightmare)
        {
            char *skilllevels[] =
            {
                "I\'m too young to die",
                "Hey, not too rough",
                "Hurt me plenty",
                "Ultra-Violence",
                "Nightmare"             
            };

            skilllevel = startskill = (skill_t)temp;
            M_SaveCVARs();
            C_Output("\"-SKILL %s\" was found on the command-line. The skill level is now \"%s\".",
                myargv[p + 1], skilllevels[startskill]);
        }
    }

    p = M_CheckParmWithArgs("-episode", 1, 1);
    if (p)
    {
        int     temp = myargv[p + 1][0] - '0';

        if ((gamemode == shareware && temp == 1) || (temp >= 1 && ((gamemode == registered
            && temp <= 3) || (gamemode == retail && temp <= 4))))
        {
            char *episodes[] =
            {
                "Knee-Deep in the Dead",
                "The Shores of Hell",
                "Inferno",
                "Thy Flesh Consumed"
            };

            startepisode = temp;
            episode = temp - 1;
            M_SaveCVARs();
            startmap = 1;
            if (gamemode == commercial)
                M_snprintf(lumpname, sizeof(lumpname), "MAP%02i", startmap);
            else
                M_snprintf(lumpname, sizeof(lumpname), "E%iM%i", startepisode, startmap);
            autostart = true;
            C_Output("\"-EPISODE %s\" was found on the command-line. The episode is now \"%s\".",
                myargv[p + 1], episodes[episode]);
        }
    }

    p = M_CheckParmWithArgs("-expansion", 1, 1);
    if (p)
    {
        int     temp = myargv[p + 1][0] - '0';

        if (gamemode == commercial && temp <= (nerve ? 2 : 1))
        {
            char *expansions[] =
            {
                "Hell on Earth",
                "No Rest for the Living"
            };

            gamemission = (temp == 1 ? doom2 : pack_nerve);
            expansion = temp - 1;
            M_SaveCVARs();
            startepisode = 1;
            startmap = 1;
            M_snprintf(lumpname, sizeof(lumpname), "MAP%02i", startmap);
            autostart = true;
            C_Output("\"-EXPANSION %s\" was found on the command-line. The expansion is now "
                "\"%s\".", myargv[p + 1], expansions[expansion]);
        }
    }

    p = M_CheckParmWithArgs("-warp", 1, 1);
    if (p)
        C_Output("\"-WARP %s\" was found on the command-line.", myargv[p + 1]);
    else
    {
        p = M_CheckParmWithArgs("+map", 1, 1);
        if (p)
            C_Output("\"+MAP %s\" was found on the command-line.", myargv[p + 1]);
    }
    if (p)
    {
        if (gamemode == commercial)
        {
            if (strlen(myargv[p + 1]) == 5 &&
                toupper(myargv[p + 1][0]) == 'M' &&
                toupper(myargv[p + 1][1]) == 'A' &&
                toupper(myargv[p + 1][2]) == 'P')
                startmap = (myargv[p + 1][3] - '0') * 10 + myargv[p + 1][4] - '0';
            else
                startmap = atoi(myargv[p + 1]);

            M_snprintf(lumpname, sizeof(lumpname), "MAP%02i", startmap);
        }
        else
        {
            if (strlen(myargv[p + 1]) == 4 &&
                toupper(myargv[p + 1][0]) == 'E' &&
                toupper(myargv[p + 1][2]) == 'M')
            {
                startepisode = myargv[p + 1][1] - '0';
                startmap = myargv[p + 1][3] - '0';
            }
            else
            {
                startepisode = myargv[p + 1][0] - '0';

                if (p + 2 < myargc)
                    startmap = myargv[p + 2][0] - '0';
                else
                    startmap = 1;
            }

            M_snprintf(lumpname, sizeof(lumpname), "E%iM%i", startepisode, startmap);
        }

        if (BTSX)
        {
            if (W_CheckMultipleLumps(lumpname) > 1)
                autostart = true;
        }
        else if (W_CheckNumForName(lumpname) >= 0)
            autostart = true;
    }

    p = M_CheckParmWithArgs("-loadgame", 1, 1);
    if (p)
        startloadgame = atoi(myargv[p + 1]);
    else
        startloadgame = -1;

    P_BloodSplatSpawner = (r_blood == r_blood_none || !r_bloodsplats_max ?
        P_NullBloodSplatSpawner : P_SpawnBloodSplat);

    M_Init();

    R_Init();

    P_Init();

    S_Init((int)(sfxVolume * 127.0f / 15.0f), (int)(musicVolume * 127.0f / 15.0f));

    HU_Init();

    ST_Init();

    AM_Init();

    C_Init();

    if (startloadgame >= 0)
    {
        I_InitKeyboard();
        if (alwaysrun)
            C_StrCVAROutput(stringize(alwaysrun), "on");
        noinput = false;
        G_LoadGame(P_SaveGameFile(startloadgame));
    }

    splashlump = W_CacheLumpName("SPLASH", PU_CACHE);
    splashpal = W_CacheLumpName("SPLSHPAL", PU_CACHE);
    titlelump = W_CacheLumpName((TITLEPIC ? "TITLEPIC" : (DMENUPIC ? "DMENUPIC" : "INTERPIC")),
        PU_CACHE);
    creditlump = W_CacheLumpName("CREDIT", PU_CACHE);
    playpal = W_CacheLumpName("PLAYPAL", PU_CACHE);

    if (gameaction != ga_loadgame)
    {
        if (autostart)
        {
            I_InitKeyboard();
            if (alwaysrun)
                C_StrCVAROutput(stringize(alwaysrun), "on");
            C_Output("Warping to %s...", lumpname);
            noinput = false;
            G_DeferredInitNew(startskill, startepisode, startmap);
        }
        else
            D_StartTitle((dboolean)M_CheckParm("-nosplash"));    // start up intro loop
    }

    startuptimer = I_GetTimeMS() - startuptimer;
    C_Output("Startup took %02i:%02i:%02i.%i to complete.",
        (startuptimer / (1000 * 60 * 60)) % 24, (startuptimer / (1000 * 60)) % 60,
        (startuptimer / 1000) % 60, (startuptimer % 1000) / 10);

    // Ty 04/08/98 - Add 5 lines of misc. data, only if nonblank
    // The expectation is that these will be set in a .bex file
    if (*startup1 || *startup2 || *startup3 || *startup4 || *startup5)
    {
        C_AddConsoleDivider();
        if (*startup1)
            C_Output(removenewlines(startup1));
        if (*startup2)
            C_Output(removenewlines(startup2));
        if (*startup3)
            C_Output(removenewlines(startup3));
        if (*startup4)
            C_Output(removenewlines(startup4));
        if (*startup5)
            C_Output(removenewlines(startup5));
    }
}

//
// D_DoomMain
//
void D_DoomMain(void)
{
    D_DoomMainSetup();          // CPhipps - setup out of main execution stack

    D_DoomLoop();               // never returns
}
